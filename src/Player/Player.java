// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package Player;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import Game.Game;
import GameResources.City;
import GameResources.ResourceType;
import GameResources.Road;
import GameResources.Settlement;
import GameResources.Structure;
import Board.Node;

/************************************************************/
/**
 * Represents an abstract player. Can be a human or a computer.
 *
 * @author Yojith Sai Biradavolu, McMaster University
 * @version Winter, 2026
 */
public abstract class Player {
	/** Represents the total number of players that have been created **/
	private static int num_players = 0;

	/** The maximum number of players allowed in a game **/
	private static final int max_players = 4;

	/** The color of the player's structures **/
	private final PlayerColor color;

	/** Represents the numerical id of the player **/
	private int id;

	/** The player's settlements, and cities **/
	private List<Structure> structures;

	/** The player's hand of resource cards **/
	private PlayerHand hand;

	/** The player's roads **/
	private List<Road> roads;

	/** The nodes the player owns and can build in and around **/
	private List<Node> nodes;

	/** The player's victory point calculator **/
	public VictoryPointCalculator victorypointcalculator; // Consider deleting

	/**
	 * Constructor for a player, whether it be a human or a computer.
	 */
	public Player() {
		if (num_players >= max_players) {
			throw new IllegalStateException("Maximum number of players reached");
		}

		this.id = num_players;
		num_players += 1;
		this.color = PlayerColor.values()[this.id];
		this.structures = new ArrayList<Structure>();
		this.hand = new PlayerHand();
		this.roads = new ArrayList<Road>();
		this.nodes = new ArrayList<Node>();
		this.victorypointcalculator = new VictoryPointCalculator();
	}

	/**
	 * Initiate the current player's turn
	 *
	 * @param game The current game
	 */
	public abstract void takeTurn(Game game);

	/**
	 * Setup of the player's structures at the beginning of the game
	 *
	 * @param game The current game
	 */
	public abstract void setup(Game game);

	/**
	 * Resets the number of players to zero. Used when restarting the game.
	 */
	public static void resetNumPlayers() {
		num_players = 0;
	}

	/**
	 *
	 */
	public void addNode(Node node) {this.nodes.add(node);}

	/**
	 * Adds a new card to the player's hand
	 *
	 * @param type New card type to be added
	 */
	public void addResource(ResourceType type) {
		this.hand.addCard(type, 1);
	}

	/**
	 * Removes a resource card from the player's hand
	 *
	 * @param type Type of resource card to be removed
	 */
	public void removeResource(ResourceType type) {
		this.hand.removeCard(type, 1);
	}

	/**
	 * Adds a structure to the player's list of structures
	 *
	 * @param structure Structure to be added
	 */
	public void addStructure(Structure structure) {
		structure.setOwner(this);
		this.structures.add(structure);
	}

	/**
	 * Removes a structure from the player's list of structures
	 *
	 * @param structure Structure to be removed
	 */
	public void removeStructure(Structure structure) {
		this.structures.remove(structure);
	}

	/**
	 * Adds a road to the player's road list
	 *
	 * @param road Road to be added
	 */
	public void addRoad(Road road) {
		road.setOwner(this);
		this.roads.add(road);
	}

	/**
	 * Calculates and returns the player's total victory points
	 *
	 * @return Player's total victory points
	 */
	public int calculateVictoryPoints() {
		return VictoryPointCalculator.calculate(this);
	}

	/**
	 * Returns the player's id
	 *
	 * @return Player id
	 */
	public int getId() {
		return id;
	}

	/**
	 * Returns the player's color based on their player id.
	 *
	 * @return Player's color
	 */
	public PlayerColor getColor() {
		return this.color;
	}

	/**
	 * Returns a list of the player's cities
	 *
	 * @return List of player's cities
	 */
	public List<City> getCities() {
		List<City> cities = new ArrayList<>();
		for (Structure structure : structures) {
			if (structure instanceof City) {
				cities.add((City) structure);
			}
		}
		return cities;
	}

	/**
	 * Returns a list of the player's settlements
	 *
	 * @return List of player's settlements
	 */
	public List<Settlement> getSettlements() {
		List<Settlement> settlements = new ArrayList<>();
		for (Structure structure : structures) {
			if (structure instanceof Settlement) {
				settlements.add((Settlement) structure);
			}
		}
		return settlements;
	}

	/**
	 * Gets the length of the player's longest road.
	 * Optimized to prevent memory overflow.
	 */
	public int longestRoad() {
		int maxLen = 0;
		// We reuse this single Set for every path check to save memory
		Set<Road> visited = new HashSet<>();

		// Iterate through all nodes associated with the player
		// (Note: To be accurate, this should ideally be ALL nodes touching the player's roads,
		// not just their settlements, but we stick to your structure here).
		for (Node n : nodes) {
			// Clear the set before starting a new path search
			visited.clear();
			int currentLen = roadLengthCalc(n, visited);
			if (currentLen > maxLen) {
				maxLen = currentLen;
			}
		}
		return maxLen;
	}

	/**
	 * Recursive DFS with Backtracking.
	 * Uses a single Set instance to track visited roads, avoiding O(N^2) memory allocation.
	 */
	private int roadLengthCalc(Node n, Set<Road> visitedRoads) {
		int longest = 0;

		// Check Left
		if (isValidRoad(n.getLeftRoad(), visitedRoads)) {
			visitedRoads.add(n.getLeftRoad()); // 1. Mark as visited
			longest = Math.max(longest, 1 + roadLengthCalc(n.getLeft(), visitedRoads));
			visitedRoads.remove(n.getLeftRoad()); // 2. Backtrack (Unmark)
		}

		// Check Right
		if (isValidRoad(n.getRightRoad(), visitedRoads)) {
			visitedRoads.add(n.getRightRoad());
			longest = Math.max(longest, 1 + roadLengthCalc(n.getRight(), visitedRoads));
			visitedRoads.remove(n.getRightRoad());
		}

		// Check Vertical
		if (isValidRoad(n.getVertRoad(), visitedRoads)) {
			visitedRoads.add(n.getVertRoad());
			longest = Math.max(longest, 1 + roadLengthCalc(n.getVert(), visitedRoads));
			visitedRoads.remove(n.getVertRoad());
		}

		return longest;
	}

	/**
	 * Helper to check if a road exists, belongs to us, and hasn't been visited.
	 */
	private boolean isValidRoad(Road r, Set<Road> visited) {
		// 1. Road must exist
		// 2. Road must NOT be in the current path (visited)
		// 3. Road must belong to THIS player (Crucial check missing in original code!)
		return r != null && !visited.contains(r) && r.getOwner() == this;
	}

	/**
	 * Returns a list of the player's roads
	 *
	 * @return List of player's roads
	 */
	public List<Road> getRoads() {
		return roads;
	}

	/**
	 * Returns a string representation of the player
	 *
	 * @return String representation of the player with their id and color
	 */
	@Override
	public String toString() {
		return "Player " + (this.id + 1)+ ", color: " + getColor();
	}

	/**
	 *
	 * @return
	 */
	public PlayerHand getHand() {
		return this.hand;
	}

	/**
	 * Returns the number of resource cards of a specific type the player has
	 *
	 * @param type Type of resource card
	 * @return Number of resource cards of the specified type
	 */
	public int getResourceAmount(ResourceType type) {
		return this.hand.getCount(type);
	}


}