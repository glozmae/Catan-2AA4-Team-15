// --------------------------------------------------------
// Code generated by Papyrus
// --------------------------------------------------------
package Game;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import Board.Board;
import Board.DiceNum;
import Board.Tile;
import Board.Node;
import Board.SetupManager;

import Player.Player;

import GameResources.ResourceType;
import GameResources.Structure;
import GameResources.City;
import GameResources.Settlement;

/**
 * Orchestrates a Catan game session.
 */
public class Game {

    private final List<Player> players;
    private final Dice dice;   // UML: depends on Dice interface
    private final Board board;

    private final int winPoints;
    private final int maxRounds;

    private int currentPlayerIndex = 0;
    private int round = 0;
    private int lastRoll = -1;

    private Player winner = null;

    /**
     * Main constructor.
     */
    public Game(List<Player> players, Dice dice, Board board,
                int winPoints, int maxRounds) {

        this.players = new ArrayList<>(Objects.requireNonNull(players));
        this.dice = Objects.requireNonNull(dice);
        this.board = Objects.requireNonNull(board);

        if (players.size() < 2 || players.size() > 4)
            throw new IllegalArgumentException("Need 2–4 players.");

        if (winPoints <= 0)
            throw new IllegalArgumentException("winPoints must be positive.");

        if (maxRounds < 1 || maxRounds > 8192)
            throw new IllegalArgumentException("Rounds must be 1–8192.");

        this.winPoints = winPoints;
        this.maxRounds = maxRounds;
    }

    /**
     * Convenience constructor (auto-create board).
     */
    public Game(List<Player> players, Dice dice,
                int winPoints, int maxRounds) {

        this(players, dice, new Board(), winPoints, maxRounds);
    }

    /**
     * UML: rollMultiDice(): Int
     */
    public int rollMultiDice() {
        return dice.roll();
    }

    /**
     * Runs simulation until winner OR round limit.
     */
    public void simulate() {

        setup();

        printBoard();

        System.out.println(
                ">>> STARTING DICE ROLL SIMULATION <<<\n"
        );

        while (winner == null && round < maxRounds) {

            for (int i = 0;
                 i < players.size() && winner == null;
                 i++) {

                playOneTurn();
            }

            round++;
        }
    }


    /**
     * Setup phase (delegated to SetupManager).
     */
    private void setup() {
        SetupManager setup = new SetupManager(board, System.currentTimeMillis());
        setup.run(players);
        currentPlayerIndex = 0;
    }

    /**
     * One player turn.
     */
    private int turnCounter = 0;

    private void nextTurn() {


        lastRoll = rollMultiDice();

        turnCounter ++;

        Player current = getCurrentPlayer();

        if (dice instanceof MultiDice md) {
            System.out.print( "Turn " + turnCounter +
                    "/ Player " + (current.getId() + 1) +
                    ": rolled " + md.getLastDie1() + " + " + md.getLastDie2() +
                    " -> "
            );
        } else {
            System.out.print( "Turn " + turnCounter +
                    ": Player " + (current.getId() + 1) +
                    " rolled " + lastRoll +
                    " -> "
            );
        }

        printProduction(lastRoll);

        distributeResources(lastRoll);

        current.takeTurn(this);

        currentPlayerIndex =
                (currentPlayerIndex + 1) % players.size();
    }


    /**
     * Wrapper: play turn + check win.
     */
    public void playOneTurn() {
        nextTurn();
        checkWin();
    }

    /**
     * Resource distribution engine.
     */
    private void distributeResources(int roll) {

        // Robber ignored per assignment
        if (roll == 7) return;

        DiceNum dn = board.getTilesForRoll(roll);
        if (dn == null) return;

        for (Tile tile : dn.getTiles()) {

            ResourceType type = tile.getType();
            if (type == null || type == ResourceType.DESERT)
                continue;

            for (Node node : tile.getNodes()) {

                Structure s = node.getStructure();
                if (s == null) continue;

                Player owner = s.getOwner();
                if (owner == null) continue;

                int payout =
                        (s instanceof City) ? 2 :
                                (s instanceof Settlement) ? 1 : 0;

                for (int i = 0; i < payout; i++) {
                    owner.addResource(type);
                }
            }
        }
    }

    /**
     * Check victory condition.
     */
    private void checkWin() {

        int longestRoad = 5;
        Player longestRoadPlayer = null;

        for (Player p : players) {
            int playerLongestRoad = p.longestRoad();
            if (playerLongestRoad > longestRoad) {
                longestRoad = playerLongestRoad;
                longestRoadPlayer = p;
            }
        }

        for (Player p : players) {

            int vp = p.calculateVictoryPoints();

            if (p == longestRoadPlayer) {
                vp += 2;
            }

            if (vp >= winPoints) {
                winner = p;
                return;
            }
        }
    }

    private void printBoard() {
        System.out.println("\n=== GENERATED BOARD (Random Desert) ===");

        for (Tile t : board.getTiles()) {
            System.out.println(t);
        }

        System.out.println("======================================\n");
    }

    private void printProduction(int roll) {

        if (roll == 7) {
            System.out.print("Producing: [ROBBER — no production] || ");
            return;
        }

        DiceNum dn = board.getTilesForRoll(roll);

        if (dn == null || dn.getTiles().isEmpty()) {
            System.out.print("Producing: [] || ");
            return;
        }

        StringBuilder sb = new StringBuilder();
        sb.append("Producing: [");

        boolean first = true;

        for (Tile t : dn.getTiles()) {

            ResourceType rt = t.getType();
            if (rt == null || rt == ResourceType.DESERT) continue;

            if (!first) sb.append(" | ");

            sb.append(rt)
                    .append(" from Tile ")
                    .append(t.getId());

            first = false;
        }

        sb.append("] || ");

        System.out.print(sb.toString());
    }



    // ---------------- Getters ----------------

    public Board getBoard() { return board; }

    public Dice getDice() { return dice; }

    public int getLastRoll() { return lastRoll; }

    public int getRound() { return round; }

    public List<Player> getPlayers() {
        return Collections.unmodifiableList(players);
    }

    public Player getCurrentPlayer() {
        return players.get(currentPlayerIndex);
    }

    public boolean isOver() { return winner != null; }

    public Player getWinner() { return winner; }
}
