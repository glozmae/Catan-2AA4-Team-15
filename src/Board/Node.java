// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package Board;

import Player.Player;
import GameResources.Road;
import GameResources.Structure;
import java.util.ArrayList;
import java.util.List;

/************************************************************/
/**
 * Represents an intersection (vertex) on the Catan game board
 * Nodes are the points where hexagonal tiles meet. They can hold
 * structures (Settlements/Cities) and connect to up to 3 other
 * nodes via Roads.
 * @author Taihan Mobasshir, 400578506, McMaster University
 */
public class Node {

	/**
	 * Unique identifier for this node (used for board setup/serialization).
	 */
	private int id;

	/**
	 * Reference to the neighboring Node in the "Left" direction.
	 */
	private Node left;

	/**
	 * Reference to the neighboring Node in the "Right" direction.
	 */
	private Node right;

	/**
	 * Reference to the neighboring Node in the "Vertical" direction.
	 */
	private Node vert;

	/**
	 * The Player who currently owns a structure on this node.
	 * Null if the node is unoccupied.
	 */
	private Player player;

	/**
	 * The type of structure built on this node (e.g., SETTLEMENT, CITY).
	 * Null if no structure exists.
	 */
	private Structure structure;

	/**
	 * The Road built on the edge connecting to the 'left' neighbor.
	 * Null if no road exists on this edge.
	 */
	private Road leftRoad;

	/**
	 * The Road built on the edge connecting to the 'right' neighbor.
	 * Null if no road exists on this edge.
	 */
	private Road rightRoad;

	/**
	 * The Road built on the edge connecting to the 'vert' neighbor.
	 * Null if no road exists on this edge.
	 */
	private Road vertRoad;

	/**
	 * Constructor for the Node class.
	 * * @param id The unique ID assigned to this vertex.
	 */
	public Node(int id) {
		this.id = id;
	}

	/**
	 * Gets the neighbor node in the left position.
	 * @return The adjacent Node object or null if none exists (board edge).
	 */
	public Node getLeft() { return left; }

	/**
	 * Gets the neighbor node in the right position.
	 * @return The adjacent Node object or null if none exists.
	 */
	public Node getRight() { return right; }

	/**
	 * Gets the neighbor node in the vertical position.
	 * @return The adjacent Node object or null if none exists.
	 */
	public Node getVert() { return vert; }

	/**
	 * Sets the neighbor node in the left position.
	 * @param node The Node to link to the left.
	 */
	public void setLeft(Node node) {
    if (node == null) return;

    if (this.left == null) this.left = node;
    if (node.right == null) node.right = this;
	}

	public void setRight(Node node) {
		if (node == null) return;

		if (this.right == null) this.right = node;
		if (node.left == null) node.left = this;
	}

	public void setVert(Node node) {
		if (node == null) return;

		if (this.vert == null) this.vert = node;
		if (node.vert == null) node.vert = this;
	}


	/**
	 * Gets the player who currently owns the structure on this node.
	 * @return The Player object, or null if unoccupied.
	 */
	public Player getPlayer() { return player; }

	/**
	 * Gets the structure details (e.g. type of building) on this node.
	 * @return The Structure object, or null.
	 */
	public Structure getStructure() { return structure; }

	/**
	 * Gets the road object on the left edge.
	 * @return The Road object if one is built, otherwise null.
	 */
	public Road getLeftRoad() { return leftRoad; }

	/**
	 * Gets the road object on the right edge.
	 * @return The Road object if one is built, otherwise null.
	 */
	public Road getRightRoad() { return rightRoad; }

	/**
	 * Gets the road object on the vertical edge.
	 * @return The Road object if one is built, otherwise null.
	 */
	public Road getVertRoad() { return vertRoad; }

	/**
	 * Sets the player for this node. Only works if no player is currently assigned.
	 */
	public void setPlayer(Player player) {
		if (this.player == null) {
			this.player = player;
		}
	}

	/**
	 * Sets the structure for this node. Only works if no structure is currently assigned.
	 */
	public void setStructure(Structure structure) {
		if (this.structure == null) {
			this.structure = structure;
		}
	}

	/**
	 * Sets the left road. Only works if the slot is empty.
	 */
	public void setLeftRoad(Road road) {
		if (this.leftRoad == null) {
			this.leftRoad = road;
		}
	}

	/**
	 * Sets the right road. Only works if the slot is empty.
	 */
	public void setRightRoad(Road road) {
		if (this.rightRoad == null) {
			this.rightRoad = road;
		}
	}

	/**
	 * Sets the vertical road. Only works if the slot is empty.
	 */
	public void setVertRoad(Road road) {
		if (this.vertRoad == null) {
			this.vertRoad = road;
		}
	}

	/**
	 * Checks if a specific player can legally build a SETTLEMENT at this node.
	 * Enforces:
	 * 1. Node is physically empty.
	 * 2. Distance Rule (no neighbors have settlements).
	 * 3. Connectivity (player must have a connecting road).
	 */
	public boolean canBuildSettlement(Player p) {
		// 1. Occupied Check: Is there already a building here?
		if (this.player != null) return false;

		// 2. Distance Rule: Are any immediate neighbors occupied?
		// (This enforces the "2 nodes away" rule)
		if (hasOccupiedNeighbor()) return false;

		// 3. Connectivity: Does the player have a road leading here?
		// (We ignore this during setup, but this method implies active play)
		if (!ownsConnectingRoad(p)) return false;

		return true;
	}

	/**
	 * Checks valid places to build a NEW ROAD starting from this node.
	 * * This handles the "Long Road" logic:
	 * - It checks if the player has "access" to this node (via an existing road chain).
	 * - It checks if the player is "blocked" by an enemy settlement.
	 * - It looks for empty edges extending outward.
	 * * @param p The player attempting to build
	 * @return A list of neighbor Nodes that form a valid, empty edge for a new road.
	 */
	public List<Node> getBuildableRoadNeighbors(Player p) {
		List<Node> validTargets = new ArrayList<>();

		// STEP 1: Can the player extend from here?
		// You can only build OUT from this node if:
		// A) You have a settlement here.
		// B) You have an incoming road AND you are not blocked by an enemy settlement.
		if (!canExtendRoadFromHere(p)) {
			return validTargets; // Dead end or invalid start point
		}

		// STEP 2: Check valid empty edges
		// Left Direction
		if (this.left != null && this.leftRoad == null) {
			validTargets.add(this.left);
		}
		// Right Direction
		if (this.right != null && this.rightRoad == null) {
			validTargets.add(this.right);
		}
		// Vertical Direction
		if (this.vert != null && this.vertRoad == null) {
			validTargets.add(this.vert);
		}

		return validTargets;
	}

	/**
	 * Helper to enforce the Distance Rule.
	 * Returns true if ANY neighbor has a settlement/city.
	 */
	private boolean hasOccupiedNeighbor() {
		if (this.left != null && this.left.player != null) return true;
		if (this.right != null && this.right.player != null) return true;
		if (this.vert != null && this.vert.player != null) return true;
		return false;
	}

	/**
	 * Helper to check if the player has at least one road touching this node.
	 */
	private boolean ownsConnectingRoad(Player p) {
		if (this.leftRoad != null && this.leftRoad.getOwner().equals(p)) return true;
		if (this.rightRoad != null && this.rightRoad.getOwner().equals(p)) return true;
		if (this.vertRoad != null && this.vertRoad.getOwner().equals(p)) return true;
		return false;
	}

	/**
	 * Helper to check the "Road Interruption" rule.
	 * You cannot build a road *through* an opponent's settlement.
	 */
	private boolean canExtendRoadFromHere(Player p) {
		// Case 1: You own the settlement on this node.
		// You can always build roads extending from your own house.
		if (this.player != null && this.player.equals(p)) return true;

		// Case 2: An ENEMY owns the settlement on this node.
		// Your road is BLOCKED. You cannot extend past their settlement.
		if (this.player != null && !this.player.equals(p)) return false;

		// Case 3: The node is empty (no settlement).
		// You can extend if you have a road reaching this node.
		return ownsConnectingRoad(p);
	}

	@Override
	public String toString() {
		return String.valueOf(id);
	}
}