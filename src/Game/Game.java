// --------------------------------------------------------
// Code generated by Papyrus
// --------------------------------------------------------
package Game;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

import Board.Board;
import Board.DiceNum;
import Board.Tile;
import Board.Node;
import Board.SetupManager;

import Player.Player;

import GameResources.ResourceType;
import GameResources.Structure;
import GameResources.City;
import GameResources.Settlement;

/**
 * Orchestrates a Catan game session.
 * Coordinates board creation and set up, turn order and progression, dice
 * rolling,
 * resource distribution, and victory point checking
 *
 * @author Elizabeth Glozman, 400559660 McMaster University
 * @author Taihan Mobasshir, 400578506, McMaster University
 */
public class Game {

    /** list of players in game */
    private final List<Player> players;

    /** Dice for rolling */
    private final Dice dice; // depends on dice interface

    /** board of tiles and nodes for game */
    private final Board board;

    /** victory point threshold */
    private final int winPoints;

    /** maximum numbe rof rounds before simulation ends */
    private final int maxRounds;

    /** index of current player in list */
    private int currentPlayerIndex = 0;

    /** number of completed rounds */
    private int round = 0;

    /** last roll value */
    private int lastRoll = -1;

    /** winner of the game (null until winner) */
    private Player winner = null;

    /**
     * Construct game with provided board
     *
     * @param players   - list of players
     * @param dice      - dice impelmentation
     * @param board     - board for the game
     * @param winPoints - victory point target
     * @param maxRounds - maximum rounds before stopping
     * @throws IllegalArgumentException if parameters are out of bounds
     * @throws NullPointerException     if players, dice, or boad are null
     */
    public Game(List<Player> players, Dice dice, Board board,
                int winPoints, int maxRounds) {

        this.players = new ArrayList<>(Objects.requireNonNull(players));
        this.dice = Objects.requireNonNull(dice);
        this.board = Objects.requireNonNull(board);

        if (players.size() < 2 || players.size() > 4)
            throw new IllegalArgumentException("Need 2–4 players.");

        if (winPoints <= 0)
            throw new IllegalArgumentException("winPoints must be positive.");

        if (maxRounds < 1 || maxRounds > 8192)
            throw new IllegalArgumentException("Rounds must be 1–8192.");

        this.winPoints = winPoints;
        this.maxRounds = maxRounds;
    }

    /**
     * Auto created board
     *
     * @param players   - list of players
     * @param dice      - dice impelmentation
     * @param winPoints - victory point target
     * @param maxRounds - maximum rounds before stopping
     */
    public Game(List<Player> players, Dice dice,
                int winPoints, int maxRounds) {

        this(players, dice, new Board(), winPoints, maxRounds);
    }

    /**
     * roll dice using implementation
     *
     * @return - dice roll value
     */
    public int rollMultiDice() {
        return dice.roll();
    }

    /**
     * Runs simulation until winner or max rounds.
     */
    public void simulate() {

        setup();

        printBoard();

        System.out.println(">>> STARTING DICE ROLL SIMULATION <<<\n");

        while (winner == null && round < maxRounds) {

            for (int i = 0; i < players.size() && winner == null; i++) {
                playOneTurn();
            }

            round++;
        }
    }

    /**
     * Setup phase by delegating to SetUpManager
     * time-based seed to randomized placements
     */
    private void setup() {
        SetupManager setup = new SetupManager(board, System.currentTimeMillis());
        setup.run(players);
        currentPlayerIndex = 0;
    }

    /** One player turn. */
    private int turnCounter = 0;

    /**
     * Executes players turn
     *
     * Rolls dice and prints output
     * prints tiles that produce resources for the roll
     * distributes resources to all adjacent owners
     * calls players decision logic
     * advances current player index
     */
    private void nextTurn() {

        // roll dice and store value
        lastRoll = rollMultiDice();

        // increment turn counter
        turnCounter++;

        Player current = getCurrentPlayer();

        // multiple dice display
        if (dice instanceof MultiDice md) {
            System.out.print("Turn " + turnCounter +
                    "/ Player " + (current.getId() + 1) +
                    ": rolled " + md.getLastDie1() + " + " + md.getLastDie2() +
                    " -> ");
        } else {
            // single dice display
            System.out.print("Turn " + turnCounter +
                    ": Player " + (current.getId() + 1) +
                    " rolled " + lastRoll +
                    " -> ");
        }

        // display tiles with resources
        printProduction(lastRoll);

        // distribute resources
        distributeResources(lastRoll);

        // actions for the turn
        current.takeTurn(this);

        // advance to next player
        currentPlayerIndex = (currentPlayerIndex + 1) % players.size();
    }

    /**
     * play turn + check win.
     */
    public void playOneTurn() {
        nextTurn();
        checkWin();
    }

    /**
     * Resource distribution:
     *
     * Robber ignored
     * Finds tiles with roll number
     * pays 1 resource per settlement, 2 for city
     */
    private void distributeResources(int roll) {

        // Robber ignored
        if (roll == 7)
            return;

        DiceNum dn = board.getTilesForRoll(roll);
        if (dn == null)
            return;

        for (Tile tile : dn.getTiles()) {

            ResourceType type = tile.getType();
            if (type == null || type == ResourceType.DESERT)
                continue;

            for (Node node : tile.getNodes()) {

                Structure s = node.getStructure();
                if (s == null)
                    continue;

                Player owner = s.getOwner();
                if (owner == null)
                    continue;

                int payout = (s instanceof City) ? 2 : (s instanceof Settlement) ? 1 : 0;

                for (int i = 0; i < payout; i++) {
                    owner.addResource(type);
                }
            }
        }
    }

    /**
     * Check victory condition.
     */
    private void checkWin() {

        int longestRoad = 5;
        Player longestRoadPlayer = null;

        for (Player p : players) {
            int playerLongestRoad = p.longestRoad();
            if (playerLongestRoad > longestRoad) {
                longestRoad = playerLongestRoad;
                longestRoadPlayer = p;
            }
        }

        for (Player p : players) {

            int vp = p.calculateVictoryPoints();

            if (p == longestRoadPlayer) {
                vp += 2;
            }

            if (vp >= winPoints) {
                winner = p;
                return;
            }
        }
    }

    /**
     * Print generated board tiles
     */
    private void printBoard() {
        System.out.println("\n=== GENERATED BOARD (Random Desert) ===");

        for (Tile t : board.getTiles()) {
            System.out.println(t);
        }

        System.out.println("======================================\n");
    }

    /**
     * Print which tiles produce a resources
     *
     * @param roll - dice roll value
     */
    private void printProduction(int roll) {

        if (roll == 7) {
            System.out.print("Producing: [ROBBER — no production] || ");
            return;
        }

        DiceNum dn = board.getTilesForRoll(roll);

        if (dn == null || dn.getTiles().isEmpty()) {
            System.out.print("Producing: [] || ");
            return;
        }

        StringBuilder sb = new StringBuilder();
        sb.append("Producing: [");

        boolean first = true;

        for (Tile t : dn.getTiles()) {

            ResourceType rt = t.getType();
            if (rt == null || rt == ResourceType.DESERT)
                continue;

            if (!first)
                sb.append(" | ");

            sb.append(rt)
                    .append(" from Tile ")
                    .append(t.getId());

            first = false;
        }

        sb.append("] || ");

        System.out.print(sb.toString());
    }

    // ---------------- Getters ----------------

    public Board getBoard() {
        return board;
    }

    public Dice getDice() {
        return dice;
    }

    public int getLastRoll() {
        return lastRoll;
    }

    public int getRound() {
        return round;
    }

    /**
     * returns unmodifable view of player list
     *
     * @return unmodifiable list of players
     */
    public List<Player> getPlayers() {
        return Collections.unmodifiableList(players);
    }

    /**
     * Reutrn player whose turn it is
     *
     * @return current player
     */
    public Player getCurrentPlayer() {
        return players.get(currentPlayerIndex);
    }

    /**
     * indicates if game has ended
     *
     * @return true if game is over
     */
    public boolean isOver() {
        return winner != null;
    }

    /**
     * Reutrn winning player or null if game unifnished
     *
     * @return winning player or null
     */
    public Player getWinner() {
        return winner;
    }
}